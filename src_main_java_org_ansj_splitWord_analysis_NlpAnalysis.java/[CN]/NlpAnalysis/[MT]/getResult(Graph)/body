{
  Merger merger=new Merger(){
    @Override public List<Term> merger(){
      if (learn == null) {
        learn=new LearnTool();
      }
      learn.learn(graph,DEFAULT_SLITWORD);
      MapCount<String> mc=null;
      if (DEFAULT_SLITWORD != null) {
        mc=new MapCount<String>();
        List<String> words=DEFAULT_SLITWORD.cut(graph.chars);
        String temp=null;
        for (        String word : words) {
          if (temp != null) {
            mc.add(temp + TAB + word);
          }
          temp=word;
          if (word.length() < 2 || DATDictionary.isInSystemDic(word) || isRuleWord(word)) {
            continue;
          }
          learn.addTerm(new NewWord(word,NatureLibrary.getNature("nw")));
        }
      }
      graph.walkPath(mc.get());
      if (graph.hasNum) {
        NumRecognition.recognition(graph.terms);
      }
      List<Term> result=getResult();
      new UserDefineRecognition(graph.terms,2,forests).recognition();
      graph.rmLittlePath();
      graph.walkPathByScore();
      new NewWordRecognition(graph.terms,learn).recognition();
      graph.walkPathByScore();
      NameFix.nameAmbiguity(graph.terms);
      result=getResult();
      for (      Term term : result) {
        learn.active(term.getName());
      }
      setRealName(graph,result);
      return result;
    }
    private List<Term> getResult(){
      List<Term> result=new ArrayList<Term>();
      int length=graph.terms.length - 1;
      for (int i=0; i < length; i++) {
        if (graph.terms[i] == null) {
          continue;
        }
        result.add(graph.terms[i]);
      }
      return result;
    }
  }
;
  return merger.merger();
}
