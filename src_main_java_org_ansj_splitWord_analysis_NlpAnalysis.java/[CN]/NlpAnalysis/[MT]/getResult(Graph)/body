{
  Merger merger=new Merger(){
    @Override public List<Term> merger(){
      if (learn == null) {
        learn=new LearnTool();
      }
      graph.walkPath();
      learn.learn(graph,splitWord);
      if (graph.hasPerson && MyStaticValue.isNameRecognition) {
        new AsianPersonRecognition().recognition(graph.terms);
        graph.walkPathByScore();
        NameFix.nameAmbiguity(graph.terms);
        new ForeignPersonRecognition().recognition(graph.terms);
        graph.walkPathByScore();
      }
      if (splitWord != null) {
        MapCount<String> mc=new MapCount<String>();
        List<String> words=splitWord.cut(graph.chars);
        String temp=null;
        TermNatures tempTermNatures=null;
        int tempOff=0;
        if (words.size() > 0) {
          String word=words.get(0);
          if (!isRuleWord(word)) {
            mc.add("???##???" + TAB + word,CRF_WEIGHT);
          }
        }
        for (        String word : words) {
          AnsjItem item=DATDictionary.getItem(word);
          Term term=null;
          if (item != AnsjItem.NULL) {
            term=new Term(word,tempOff,DATDictionary.getItem(word));
          }
 else {
            TermNatures termNatures=NatureRecognition.getTermNatures(word);
            if (termNatures != TermNatures.NULL) {
              term=new Term(word,tempOff,termNatures);
            }
 else {
              term=new Term(word,tempOff,TermNatures.NW);
            }
          }
          if (isRuleWord(word)) {
            temp=null;
            tempOff+=word.length();
            continue;
          }
          TermUtil.insertTerm(graph.terms,term,InsertTermType.SCORE_ADD_SORT);
          tempOff+=word.length();
          if (temp != null) {
            if (tempTermNatures != TermNatures.NW && term.termNatures() != TermNatures.NW) {
              mc.add(temp + TAB + word,CRF_WEIGHT);
            }
          }
          temp=word;
          tempTermNatures=term.termNatures();
          if (term.termNatures() != TermNatures.NW || word.length() < 2) {
            continue;
          }
          learn.addTerm(new NewWord(word,Nature.NW));
        }
        if (tempTermNatures != TermNatures.NW) {
          mc.add(temp + TAB + "???##???",CRF_WEIGHT);
        }
        graph.walkPath(mc.get());
      }
 else {
        MyStaticValue.LIBRARYLOG.warn("not find crf model you can run DownLibrary.main(null) to down !\n or you can visit http://maven.nlpcn.org/down/library.zip to down it ! ");
      }
      if (graph.hasNum && MyStaticValue.isNumRecognition) {
        new NumRecognition().recognition(graph.terms);
      }
      List<Term> result=getResult();
      new UserDefineRecognition(InsertTermType.SCORE_ADD_SORT,forests).recognition(graph.terms);
      graph.rmLittlePath();
      graph.walkPathByScore();
      new NewWordRecognition(learn).recognition(graph.terms);
      graph.walkPathByScore();
      result=getResult();
      for (      Term term : result) {
        learn.active(term.getName());
      }
      setRealName(graph,result);
      return result;
    }
    private List<Term> getResult(){
      List<Term> result=new ArrayList<Term>();
      int length=graph.terms.length - 1;
      for (int i=0; i < length; i++) {
        if (graph.terms[i] == null) {
          continue;
        }
        result.add(graph.terms[i]);
      }
      return result;
    }
  }
;
  return merger.merger();
}
